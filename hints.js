// mouseover tooltips for various UI elements

var titles = {
    "Sampling steps": ",	Скільки проходів додавання деталізації робити; вищі значення більш реалістично але довго; низькі значення для стилізації і малюнків",
    "Sampling method": ",	Який алгоритм використовувати для створення зображення",
    "GFPGAN": ",	Покращити  неякісне обличчя  за допомогою нейронки  GFPGAN",
    "Euler a": ",	Euler Ancestral - дуже креативний, кожен може отримати зовсім іншу картину залежно від кількості кроків, встановлення кроків вище 30-40 не допомагає",
    "DDIM": ",	Denoising Diffusion Implicit Models - Знешумлення  неявних моделей – найкраще в малюванні",
    "UniPC": ",	Unified Predictor-Corrector Уніфікована структура предиктора-коректора для швидкої вибірки  моделей ",
    "DPM adaptive": ",	Ігнорує кількість кроків - використовує кількість кроків, визначену CFG і роздільною здатністю",

    "\u{1F4D0}": ",		Автоматично визначити розмір полотна img2img",
    "Batch count": ",	Скільки зображень генерувати послівдовно(не впливає на швидкість генерації та навантаження на VRAM)",
    "Batch size": ",	Скільки зображень генерувати паралельно (підвищує швидкість генерації за рахунок більшого навантаження на VRAM)",
    "CFG Scale": ",		Classifier Free Guidance Scale- наскільки сильно зображення має відповідати промпту - нижчі  значення ніж 7 дають більш творчі результати (по факту  це  шкала насиченості кольорів)",
    "Seed": "сід код генератора  випадкових чисел - якщо ви створюєте зображення з тим самим сідом що й інше зображення, ви отримаєте той самий результат",
    "\u{1f3b2}\ufe0f": ".	значення -1, генеруватиме рандомний Сід",
    "\u267b\ufe0f": ".	повторне використання останнього згенерованого Сіду",
    "\u2199\ufe0f": ".	Read generation parameters from prompt or last generation if prompt is empty into user interface.",
    "\u{1f4c2}": ".	Відкрити каталог зображень",
    "\u{1f4be}": ".	Зберегти Шаблон",
    "\u{1f5d1}\ufe0f": ".	Очистити промпт",
    "\u{1f4cb}": ".	Вставити текст шаблону у промпту",
    "\u{1f4d2}": ".	Вставте доступні значення в поле 123",
    "\u{1f3b4}": ".	показати панель Чекпоінтів",
    "\u{1f300}": ".	Відновити прогрес",

    "Inpaint a part of image": ",	Намалюйте маску поверх зображення, і сценарій відновить масковану область із вмістом відповідно до підказки",
    "SD upscale": "Upscale  розділяє зоображення на тайли, покращує  кожен тьайл окремо за допомогою img2img, і об’єднує все зображення назад",

    "Just resize": ",	Змінить розмір зображення до обраної роздільноті. Якщо висота та ширина не різні, ви отримаєте некоректне розтягуван6ня зображення",
    "Crop and resize": ",	Збільшить розмір зображення так, щоб полотно було  повністю заповнене . Обріже краї, які невлазять.",
    "Resize and fill": ",	Змінить розмір зображення по розміру полотна. Заповніть порожній простір кольорами зображення.",

    "Mask blur": ",	Наскільки розмити маску перед обробкою, у пікселях.",
    "Masked content": ",	Що помістити всередину замаскованої області перед обробкою за допомогою Stable Diffusion.",
    "fill": ",	заповнити  кольорами зображення",
    "original": ",	брати кольори з зоображення",
    "latent noise": ",	заповнити  прихованим просторовим шумом",
    "latent nothing": ",	заповнити  латентними space zeroes - (по факту це усереднений колір з усіх кольорів малюнку)",
    "Inpaint at full resolution": ",	Збільшить масштаб маскованої області до встановленої роздільності, зафарбує, зменшить масштаб назад і вставе в оригінальне зображення",

    "Denoising strength": ",	Визначає, наскільки мало поважає алгоритм вміст зображення. При 0 нічого не зміниться, а при 1 ви отримаєте непов’язане зображення. Якщо значення нижче 1.0 , обробка займатиме менше кроків, ніж вказано повзунком 'Кількість проходів'(Sampling Steps).",

    "Skip": ",	Зупинити обробку поточного зображення та почати обробку наступного.",
    "Interrupt": ",	Припинить обробку зображень і поверне будь-які результати, згенеровані до цього часу.",
    "Save": ",	Записати зображення в каталог (за замовчуванням - log/images) і параметри генерації у файл csv.",

    "X values": ",	Розділяйте значення для осі X комами.",
    "Y values": ",	Розділіть значення для осі Y комами.",

    "None": ",	Не робить нічого ",
    "Prompt matrix": ",	Розділіть промпт на частини вертикальною  рискою (|), і скрипт створить картинку для кожної їх комбінації (крім першої частини, яка буде присутня у всіх комбінаціях)",
    "X/Y/Z plot": ",	Створіть таблицю з картинок, де зображення матимуть різні параметри. Використовуйте дані нижче, щоб указати, які параметри будуть послідовні у  стовпців і рядків",
    "Custom code": ",	Запустіть код Python. Тільки досвідчений користувач. Потрібно запустити програму з --allow-code, щоб це працювало",

    "Prompt S/R": ",	Розділіть список слів комами, і перше слово буде використано як ключове: скрипт буде шукати це слово в промпті та замінювати його на інші",
    "Prompt order": ",	Розділіть список слів комами, і скрипт створить варіант промту з цими словами для кожного можливого чередування слів",

    "Tiling": ",	Створіть зображення тайлової текстури",
    "Tile overlap": ",	Для SD upscale, яка кількість пікселів має бути між фрагментами. Плитки перекриваються таким чином, що коли вони знову об’єднані в одне зображення, не залишається чітко видимого шва.",

    "Variation seed": ",	Сід іншої картинки, яка буде змішана  з поточною.",
    "Variation strength": ",	Наскільки сильна варіація для створення. При 0 ефекту не буде. На 1 ви отримаєте повну картину з варіаційним Сідом (за винятком зразків предків, де ви просто отримаєте щось).",
    "Resize seed from height": ",	 створити зображення, схоже на те, що було  створено за допомогою того самого Сіда із зазначеною роздільністю",
    "Resize seed from width": " ,	створити зображення, схоже на те, що було  створено за допомогою того самого Сіда із зазначеною роздільністю",

    "Interrogate": ",	згенерувати  текстовий промпт з  зображення.",

    "Images filename pattern": ",	Використовуйте такі теги, як [seed] і [date], щоб визначити спосіб вибору імен файлів для зображень. За замовчуванням залиште порожнім.",
    "Directory name pattern": ",	Використовуйте такі теги, як [seed] і [date], щоб визначити спосіб вибору підкаталогів для зображень і сіток. За замовчуванням залиште порожнім.",
    "Max prompt words": ",	Встановіть максимальну кількість слів для використання в параметрі [prompt_words]; УВАГА: Якщо слова занадто довгі, вони можуть перевищувати максимальну довжину шляху до файлу, який може обробити система",

    "Loopback": ",	Виконує обробку img2img кілька разів. Вихідні зображення використовуються як вхідні для наступного циклу.",
    "Loops": ",	Скільки разів обробити зображення. Кожен вихід використовується як вхід наступного циклу. Якщо встановлено значення 1, поведінка буде такою, наче цей сценарій не використовувався.",
    "Final denoising strength": ",	Сила шумозаглушення для останнього циклу кожного зображення в пакеті.",
    "Denoising strength curve": ",	Крива усунення шумів контролює швидкість зміни сили усунення шумів у кожному циклі. Агресивний(Aggressive): більшість змін відбудеться на початку циклів. Лінійний(Linear): зміна буде постійною в усіх циклах. Ледачий(Lazy): більшість змін відбудеться в кінці циклів.",

    "Style 1": ",	Шаблон для застосування; Шаблони містять компоненти як для позитивних, так і для негативних промптів і застосовуються до обох",
    "Style 2": ",	Шаблон для застосування; Шаблони містять компоненти як для позитивних, так і для негативних промптів і застосовуються до обох",
    "Apply style": ",	Вставте обраний шаблон в поле промпт",
    "Create style": ",	Зберегти поточний промпт як шаблон. Якщо ви додасте маркер {prompt} до тексту, шаблон використовуватиме його для заміни на вказані слова в промті, без параметра {prompt} слова будуть вставлятися  в самому початку",

    "Checkpoint name": ",	Завантажує вказаний  Чекпоінт  перед створенням зображень. Ви можете використовувати хеш або частину назви файлу (як видно в налаштуваннях) для назви контрольної точки. Рекомендується використовувати з віссю Y для компактності таблиці.",
    "Inpainting conditioning mask strength": ",	Застосовується лише до моделей inpainting. Визначає, наскільки сильно маскувати вихідне зображення для inpainting та img2img. 1.0 означає повністю замасковане, що є типовою поведінкою. 0,0 означає повністю незамасковане кондиціонування. Менші значення допоможуть зберегти загальну композицію зображення, але будуть погано під час великих змін.",

    "vram": ",	Torch активний: максимальний обсяг VRAM, який використовується Torch під час генерації, за винятком кешованих даних.\nTorch зарезервований: максимальний обсяг VRAM, виділений Torch, включаючи всі активні та кешовані дані.\nSys VRAM: максимальний обсяг розподілу VRAM для всіх програм / загальна GPU VRAM (peak utilization%).",

    "Eta noise seed delta": ",	Якщо це значення відмінне від нуля, воно буде додано до початкового числа та використано для ініціалізації RNG для шумів під час використання семплерів із Eta. Ви можете використовувати це для створення ще більшої різноманітності зображень, або ви можете використовувати це для порівняння зображень іншого програмного забезпечення, якщо ви знаєте, що робите.",

    "Filename word regex": ",	Цей регулярний вираз використовуватиметься для виділення слів із назви файлу, і вони будуть об’єднані за допомогою параметра нижче в текст мітки, який використовується для навчання. Залиште поле порожнім, щоб зберегти текст назви файлу без змін.",
    "Filename join string": ",	Цей рядок використовуватиметься для об’єднання розділених слів в один рядок, якщо ввімкнено параметр вище.",

    "Quicksettings list": ",	Список назв налаштувань, розділених комами, для налаштувань, які мають перейти на панель швидкого доступу вгорі, а не на звичайну вкладку налаштувань. Дивіться modules/shared.py для назв налаштувань. Для застосування потрібен перезапуск.",

    "Weighted sum": ",	Результат = A * (1 - M) + B * M",
    "Add difference": ",	Результат = A + (B - C) * M",
    "No interpolation": ",	Результат = A",

    "Initialization text": ",	Якщо кількість токенів перевищує кількість векторів, деякі з них можуть бути пропущені.\nЗалиште текстове поле порожнім, щоб почати з обнулених векторів",
    "Learning rate": ",	Як швидко має проходити тренування. Низькі значення потребуватимуть більше часу для навчання, високі значення можуть не збігатися (не давати точні результати) та/або порушувати вбудовування (Це трапляється, якщо ви бачите Loss: nan у текстовому полі інформації про навчання. Якщо це трапиться, вам потрібно вручну відновити ваше вбудовування зі старішої непошкодженої резервної копії).\n\nВи можете встановити одне числове значення або кілька швидкостей навчання за допомогою синтаксису:\n\n   rate_1:max_steps_1, rate_2:max_steps_2, ...\n\nEG:   0.005:100, 1e-3:1000, 1e-5\n\n Буде тренуватися зі швидкістю 0,005 для перших 100 кроків, потім 1e-3 до 1000 кроків, потім 1e-5 для всіх решти кроків.",

    "Clip skip": ",	Параметр ранньої зупинки для моделі CLIP; 1 – це зупинка на останньому шарі, як зазвичай, 2 – зупинка на передостанньому шарі тощо.",

    "Approx NN": ",	Дешева апроксимація нейронної мережі. Дуже швидко порівняно з VAE, але створює зображення з у 4 рази меншою роздільною здатністю по горизонталі/вертикалі та нижчою якістю.",
    "Approx cheap": ",	Дуже дешеве наближення. Дуже швидкий порівняно з VAE, але створює зображення з у 8 разів меншою роздільною здатністю по горизонталі/вертикалі та надзвичайно низькою якістю.",

    "Hires. fix": ",	Використовуйте двоетапний процес, щоб частково створити зображення з меншою роздільною здатністю, збільшити масштаб, а потім покращити його деталі без зміни композиції",
    "Hires steps": ",	Кількість проходів(sampling steps) для масштабованого зображення. Якщо 0, використовується те саме, що й для оригіналу.",
    "Upscale by": ",	Налаштовує розмір зображення шляхом множення вихідної ширини та висоти на вибране значення. Ігнорується, якщо «Змінити ширину» або «Змінити висоту» не дорівнює нулю.",
    "Resize width to": ",	Змініть розмір зображення до цієї ширини. Якщо значення 0, ширина визначається за будь-яким із двох сусідніх повзунків.",
    "Resize height to": ",	Змініть розмір зображення до цієї висоти. Якщо значення 0, ширина визначається за будь-яким із двох сусідніх повзунків.",
    "Multiplier for extra networks": ",	Додаючи до промпту додаткову мережу, наприклад Hypernetwork або Lora, використовуйте для неї цей множник.",
    "Discard weights with matching name": ",	Регулярний вираз; якщо назва ваги збігається з нею, ваги не записуються в результуючу контрольну точку. Використовуйте ^model_ema, щоб відхилити ваги EMA.",
    "Extra networks tab order": ",	Comma-separated list of tab names; tabs listed here will appear in the extra networks UI first and in order lsited.",
    "Negative Guidance minimum sigma": ",	Пропустити негативну підказку для кроків, на яких зображення вже здебільшого приглушено; чим вище це значення, тим більше буде пропусків; забезпечує підвищення продуктивності в обмін на незначне зниження якості."
};

function updateTooltipForSpan(span) {
    if (span.title) return; // already has a title

    let tooltip = localization[titles[span.textContent]] || titles[span.textContent];

    if (!tooltip) {
        tooltip = localization[titles[span.value]] || titles[span.value];
    }

    if (!tooltip) {
        for (const c of span.classList) {
            if (c in titles) {
                tooltip = localization[titles[c]] || titles[c];
                break;
            }
        }
    }

    if (tooltip) {
        span.title = tooltip;
    }
}

function updateTooltipForSelect(select) {
    if (select.onchange != null) return;

    select.onchange = function() {
        select.title = localization[titles[select.value]] || titles[select.value] || "";
    };
}

var observedTooltipElements = {SPAN: 1, BUTTON: 1, SELECT: 1, P: 1};

onUiUpdate(function(m) {
    m.forEach(function(record) {
        record.addedNodes.forEach(function(node) {
            if (observedTooltipElements[node.tagName]) {
                updateTooltipForSpan(node);
            }
            if (node.tagName == "SELECT") {
                updateTooltipForSelect(node);
            }

            if (node.querySelectorAll) {
                node.querySelectorAll('span, button, select, p').forEach(updateTooltipForSpan);
                node.querySelectorAll('select').forEach(updateTooltipForSelect);
            }
        });
    });
});
